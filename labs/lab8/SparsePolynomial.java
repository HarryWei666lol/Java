package lab8;

import java.util.HashSet;
import java.util.Set;

import sedgewick.StdDraw;

/**
 * An immutable Polynomial class.  This means that once
 *   the constructor has finished, nothing about this
 *   Polynomial can change.  We check for this in
 *   our testing of your implementation.
 *   
 * Also this implementation is sparse, in the sense
 * that terms with 0 coefficients, supplied or implied,
 * can and should not be represented here.
 * 
 * For example, 5 + x^100 is a Polynomial with a 0-degree
 * term (5) and a 100-degree term (1).   The 99 terms in between are
 * not mentioned here and are implied to have a coefficient of 0.
 * Moreover, x^202 power would also have a coefficient of 0 for this
 * Polynomial.   By using a sparse representation, we retain only
 * the 0-degree and 100-degree terms in this case.
 * 
 * @author Harry Wei
 *
 */
public class SparsePolynomial implements Polynomial {

	//
	// TODO Declare instance variable(s)
	//

	private final Set<Term> a; // a is the type of Set<Term>


	/**
	 * Primary constructor
	 * @param array  collection of Terms for this Polynomial.  
	 * Some coefficients may be 0.0, but those Terms should not
	 * be retained in the Set.
	 */
	public SparsePolynomial(Term[] array) { //Constructor
		// purpose of the Constructor:do more than instantiate the HashSet. 
		// It is provided an array of Term. 
		// These should be added to the HashSet<Term>
		// Add each Term to your HashSet except for those that have a 0 coefficient.
		// At most one entry in the Set of a given degree.

		this.a=new HashSet<Term>();
		double b[]=new double[1000];// create an array of b
		//initialize b to be zero
		for(int i = 0; i<b.length;i++) {
			b[i]=0;
		}
		//add coefficient to corresponding degree
		for(int i =0; i < array.length; i++) {
			b[array[i].getDegree()]=b[array[i].getDegree()]+array[i].getCoefficient();
			// for example, there is a term 2x^3 in the original input array named array and
			// this line of code puts the coefficient 2 into the 3rd index of an array named b 
			// at the index of 3, an addition operation of 0+3 is performed
		}
		for(int i =0; i < b.length;i++) {
			if(b[i]!=0) {
				a.add(new Term(b[i],i)); // from the previous 2x^3 example, 2 is added to the set at the index of 3
			}
		}
	}// End of Constructor: the non-empty terms exist now in the set named Term


	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((a == null) ? 0 : a.hashCode());
		return result;
	}


	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SparsePolynomial other = (SparsePolynomial) obj;
		if (a == null) {
			if (other.a != null)
				return false;
		} else if (!a.equals(other.a))
			return false;
		return true;
	}


	/**
	 * This is completed already for you.  Do not change this constructor.
	 * Convenience constructor to create an empty Polynomial.
	 * Calls the primary constructor passing an empty array of Terms.
	 */
	public SparsePolynomial() {// mutator
		this(new Term[0]);// ?
	}

	public int degree() {
		int ans=0;
		for(Term i:a) { // the way to go over the whole Set or List, not used in Array 
			              // a is the set defined in the instance variable
			if(i.getDegree()>ans) { // gets the highest mathematical degree
				ans=i.getDegree();
			}
		}
		return ans;
	}






	/**
	 * This is provided for you.   
	 * Really, no need to thank me.
	 */
	@Override // @Override means this method is auto-generated by implementing the interface: Polynomial.java 
	public void plot(double lowx, double highx, double incx) {
		//
		// Determine min and max for y values
		//
		double maxy = this.evaluate(lowx);
		double miny = this.evaluate(lowx);
		for (double x=lowx; x < highx; x = x + incx) {
			double y = this.evaluate(x);
			maxy = Math.max(maxy, y);
			miny = Math.min(miny, y);
		}
		StdDraw.setXscale(lowx, highx);
		StdDraw.setYscale(miny, maxy);
		for (double x=lowx; x < highx; x = x + incx) {
			double y = this.evaluate(x);
			StdDraw.point(x, y);
		}
	}

	@Override
	public double getCoefficientAtDegree(int degree) {
	
		double ans =0;
		for( Term i : a) {
			if(i.getDegree() == degree) { // check whether the requested degree exists in the Set named Term
				ans = i.getCoefficient();
			}
		}
		return ans;
	}

	@Override
	public double evaluate(double x) {

		double sum = 0;
		for(Term i : a) {
			sum+=i.evaluateTermAtX(x); // equivalent to: sum = sum + i.evaluatedTermAtX(x);
		}
		return sum;
	}

	@Override
	public Term[] toArray() {// most difficult in this lab
		double temp[] = new double[degree()+1]; // degree() + 1 = length of degree 
		for(int i =0;i<temp.length;i++) {
			temp[i]=0; // generates an array consisting of all 0s
		}
		for(Term i:a) {
			temp[i.getDegree()]=i.getCoefficient(); // temp is an array of coefficients
			// for example, there is a term 2x^3 in the original input array named array and
			// this line of code puts the coefficient 2 in the 3rd index of the array named temp
		}
		Term[] fullTerm = new Term[temp.length]; // generate an ADT of type Term[] named fullTerm
		for(int i=0;i<temp.length;i++) { // fullTerm is a type Term[] of completed Term e.g. 2x^3(full term)
			fullTerm[i]=new Term(temp[i],i); // Term is from the other class named Term.java
		}
		return fullTerm;
	}



	@Override
	public Polynomial derivative() {
		Term[] t = new Term[degree()+1];
		for(int i =0;i<t.length;i++) {
			t[i]=new Term(0,0); // a polynomial with every Term being 0x^0
		}
		for(Term i:a) {
			if(i.getDegree()!=0) {// prevent 16x^-1 from happening
				t[i.getDegree()]=new Term(i.getDegree()*i.getCoefficient(),i.getDegree()-1);
			}
		}
		SparsePolynomial s = new SparsePolynomial(t);
		return s;
	}

	@Override
	public Polynomial sum(Polynomial other) {

		Term[] t = this.toArray(); // this.toArray called a method written earlier & above
		Term[] t1 = other.toArray();
		int max = Math.max(t.length,t1.length);
		Term[] sumOfTwoPolynomials = new Term[max];
		for(int i =0;i<max;i++) { // beginning of loop
			if(i>=t.length) { // the last term of the longer polynomial goes without summation 
				                  //to the new array named sumOfTwoPolynomials
				sumOfTwoPolynomials[i]=t1[i];
			}
			else if(i>=t1.length) { // the last term of the longer polynomial goes without summation 
                //to the new array named sumOfTwoPolynomials
				sumOfTwoPolynomials[i]=t[i];
			}
			else {
				sumOfTwoPolynomials[i]=new Term(t[i].getCoefficient()+t1[i].getCoefficient(),i);
			}
		}// end of loop
		SparsePolynomial s = new SparsePolynomial(sumOfTwoPolynomials);
		return s;
	}
	
		@Override
		public Polynomial addTerm(Term t) {
			// ?? forgot to do something ??
//			SparsePolynomial p = new SparsePolynomial();
//			return p;
			Term[] temp = new Term[1];
			temp[0] = t;
			SparsePolynomial a = new SparsePolynomial(temp);
			return this.sum(a);
		}

// testOneMissingTerm & testLikeTheresNoTomorrow just passed without me doing anything. Why is it that way?

}
